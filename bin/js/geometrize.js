// Generated by Haxe 3.4.2 (git build master @ 890f8c7)
(function ($global) { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var CanvasTools = function() { };
CanvasTools.__name__ = true;
CanvasTools.downScaleCanvas = function(cv,scale) {
	if(scale <= 0.0 || scale >= 1.0) {
		throw new js__$Boot_HaxeError("Scale must be a positive number < 1");
	}
	var sqScale = scale * scale;
	var sw = cv.width;
	var sh = cv.height;
	var tw = sw * scale | 0;
	var th = sh * scale | 0;
	var sx = 0;
	var sy = 0;
	var sIndex = 0;
	var tx = 0;
	var ty = 0;
	var yIndex = 0;
	var tIndex = 0;
	var tX = 0;
	var tY = 0;
	var w = 0.0;
	var nw = 0.0;
	var wx = 0.0;
	var nwx = 0.0;
	var wy = 0.0;
	var nwy = 0.0;
	var crossX = false;
	var crossY = false;
	var sBuffer = cv.getContext("2d").getImageData(0,0,sw,sh).data;
	var this1 = new Float32Array(3 * tw * th);
	var tBuffer = this1;
	var sR = 0.0;
	var sG = 0.0;
	var sB = 0.0;
	while(sy < sh) {
		ty = sy * scale | 0;
		tY = ty | 0;
		yIndex = 3 * tY * tw | 0;
		crossY = tY != (ty + scale | 0);
		if(crossY) {
			wy = tY + 1 - ty;
			nwy = ty + scale - tY - 1;
		}
		sx = 0;
		while(sx < sw) {
			tx = sx * scale | 0;
			tX = tx | 0;
			tIndex = yIndex + tX * 3 | 0;
			crossX = tX != Math.floor(tx + scale);
			if(crossX) {
				wx = tX + 1 - tx;
				nwx = tx + scale - tX - 1 | 0;
			}
			sR = sBuffer[sIndex];
			sG = sBuffer[sIndex + 1];
			sB = sBuffer[sIndex + 2];
			if(!crossX && !crossY) {
				var _g = tIndex;
				var _g1 = tBuffer;
				_g1[_g] += sR * sqScale;
				var _g2 = tIndex + 1;
				var _g11 = tBuffer;
				_g11[_g2] += sG * sqScale;
				var _g3 = tIndex + 2;
				var _g12 = tBuffer;
				_g12[_g3] += sB * sqScale;
			} else if(crossX && !crossY) {
				w = wx * scale;
				var _g4 = tIndex;
				var _g13 = tBuffer;
				_g13[_g4] += sR * w;
				var _g5 = tIndex + 1;
				var _g14 = tBuffer;
				_g14[_g5] += sG * w;
				var _g6 = tIndex + 2;
				var _g15 = tBuffer;
				_g15[_g6] += sB * w;
				nw = nwx * scale;
				var _g7 = tIndex + 3;
				var _g16 = tBuffer;
				_g16[_g7] += sR * nw;
				var _g8 = tIndex + 4;
				var _g17 = tBuffer;
				_g17[_g8] += sG * nw;
				var _g9 = tIndex + 5;
				var _g18 = tBuffer;
				_g18[_g9] += sB * nw;
			} else if(crossY && !crossX) {
				w = wy * scale;
				var _g10 = tIndex;
				var _g19 = tBuffer;
				_g19[_g10] += sR * w;
				var _g20 = tIndex + 1;
				var _g110 = tBuffer;
				_g110[_g20] += sG * w;
				var _g21 = tIndex + 2;
				var _g111 = tBuffer;
				_g111[_g21] += sB * w;
				nw = nwy * scale;
				var _g22 = tIndex + 3 * tw;
				var _g112 = tBuffer;
				_g112[_g22] += sR * nw;
				var _g23 = tIndex + 3 * tw + 1;
				var _g113 = tBuffer;
				_g113[_g23] += sG * nw;
				var _g24 = tIndex + 3 * tw + 2;
				var _g114 = tBuffer;
				_g114[_g24] += sB * nw;
			} else {
				w = wx * wy;
				var _g25 = tIndex;
				var _g115 = tBuffer;
				_g115[_g25] += sR * w;
				var _g26 = tIndex + 1;
				var _g116 = tBuffer;
				_g116[_g26] += sG * w;
				var _g27 = tIndex + 2;
				var _g117 = tBuffer;
				_g117[_g27] += sB * w;
				nw = nwx * wy;
				var _g28 = tIndex + 3;
				var _g118 = tBuffer;
				_g118[_g28] += sR * nw;
				var _g29 = tIndex + 4;
				var _g119 = tBuffer;
				_g119[_g29] += sG * nw;
				var _g30 = tIndex + 5;
				var _g120 = tBuffer;
				_g120[_g30] += sB * nw;
				nw = wx * nwy;
				var _g31 = tIndex + 3 * tw;
				var _g121 = tBuffer;
				_g121[_g31] += sR * nw;
				var _g32 = tIndex + 3 * tw + 1;
				var _g122 = tBuffer;
				_g122[_g32] += sG * nw;
				var _g33 = tIndex + 3 * tw + 2;
				var _g123 = tBuffer;
				_g123[_g33] += sB * nw;
				nw = nwx * nwy;
				var _g34 = tIndex + 3 * tw + 3;
				var _g124 = tBuffer;
				_g124[_g34] += sR * nw;
				var _g35 = tIndex + 3 * tw + 4;
				var _g125 = tBuffer;
				_g125[_g35] += sG * nw;
				var _g36 = tIndex + 3 * tw + 5;
				var _g126 = tBuffer;
				_g126[_g36] += sB * nw;
			}
			sIndex += 4;
			++sx;
		}
		++sy;
	}
	var result = window.document.createElement("canvas");
	result.width = tw;
	result.height = th;
	var resultContext = result.getContext("2d");
	var resultImage = resultContext.getImageData(0,0,tw,th);
	var tByteBuffer = resultImage.data;
	var pxIndex = 0;
	sIndex = 0;
	tIndex = 0;
	while(pxIndex < tw * th) {
		tByteBuffer[tIndex] = Math.ceil(tBuffer[sIndex]);
		tByteBuffer[tIndex + 1] = Math.ceil(tBuffer[sIndex + 1]);
		tByteBuffer[tIndex + 2] = Math.ceil(tBuffer[sIndex + 2]);
		tByteBuffer[tIndex + 3] = 255;
		sIndex += 3;
		tIndex += 4;
		++pxIndex;
	}
	resultContext.putImageData(resultImage,0,0);
	return result;
};
var GeometrizeWorkerInterface = function() {
	var _gthis = this;
	this.worker = new Worker("js/geometrize_worker.js");
	this.worker.onmessage = function(message) {
		_gthis.onMessage(message.data);
	};
};
GeometrizeWorkerInterface.__name__ = true;
GeometrizeWorkerInterface.prototype = {
	postMessage: function(message) {
		this.worker.postMessage(message);
	}
	,onMessage: function(message) {
	}
	,__class__: GeometrizeWorkerInterface
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
var Main = function() {
	this.targetImage = null;
	this.shapeData = [];
	this.shapeMutationsPerStep = 100;
	this.candidateShapesPerStep = 50;
	this.shapeOpacity = 128;
	this.shapeTypes = geometrize__$ArraySet_ArraySet_$Impl_$.create([4]);
	this.maxInputImageSize = 1024;
	this.worker = new GeometrizeWorkerInterface();
	window.onload = $bind(this,this.onWindowLoaded);
};
Main.__name__ = true;
Main.main = function() {
	var main = new Main();
};
Main.prototype = {
	get_shapeCount: function() {
		return this.shapeData.length;
	}
	,get_maxShapeCountLimit: function() {
		var text = Main.maxShapesCapTextEdit.value;
		var value = Std.parseInt(text);
		if(value != null) {
			return value;
		}
		return 7000;
	}
	,set_maxShapeCountLimit: function(limit) {
		Main.maxShapesCapTextEdit.value = limit == null ? "null" : "" + limit;
		return limit;
	}
	,onWindowLoaded: function() {
		Main.rotatedEllipsesCheckbox.checked = true;
		var _gthis = this;
		noUiSlider.create(Main.shapeOpacitySlider,{ start : [this.shapeOpacity], connect : "lower", range : { "min" : [1,1], "max" : [255]}, pips : { mode : "range", density : 10}});
		this.createTooltips(Main.shapeOpacitySlider);
		Main.shapeOpacitySlider.noUiSlider.on("change",function(values,handle,rawValues) {
			_gthis.shapeOpacity = values[handle] | 0;
		});
		Main.shapeOpacitySlider.noUiSlider.on("update",function(values1,handle1,rawValues1) {
			_gthis.updateTooltips(Main.shapeOpacitySlider,handle1,values1[handle1] | 0);
		});
		noUiSlider.create(Main.randomShapesPerStepSlider,{ start : [this.candidateShapesPerStep], connect : "lower", range : { "min" : [10,1], "max" : [300]}, pips : { mode : "range", density : 10}});
		this.createTooltips(Main.randomShapesPerStepSlider);
		Main.randomShapesPerStepSlider.noUiSlider.on("change",function(values2,handle2,rawValues2) {
			_gthis.candidateShapesPerStep = values2[handle2] | 0;
		});
		Main.randomShapesPerStepSlider.noUiSlider.on("update",function(values3,handle3,rawValues3) {
			_gthis.updateTooltips(Main.randomShapesPerStepSlider,handle3,values3[handle3] | 0);
		});
		noUiSlider.create(Main.shapeMutationsPerStepSlider,{ start : [this.shapeMutationsPerStep], connect : "lower", range : { "min" : [10,1], "max" : [300]}, pips : { mode : "range", density : 10}});
		this.createTooltips(Main.shapeMutationsPerStepSlider);
		Main.shapeMutationsPerStepSlider.noUiSlider.on("change",function(values4,handle4,rawValues4) {
			_gthis.shapeMutationsPerStep = values4[handle4] | 0;
		});
		Main.shapeMutationsPerStepSlider.noUiSlider.on("update",function(values5,handle5,rawValues5) {
			_gthis.updateTooltips(Main.shapeMutationsPerStepSlider,handle5,values5[handle5] | 0);
		});
		var _gthis1 = this;
		Main.runPauseButton.addEventListener("click",function() {
			_gthis1.set_running(!_gthis1.running);
		},false);
		Main.openImageFileInput.addEventListener("change",function(e) {
			if(Main.openImageFileInput.files == null || Main.openImageFileInput.files.length == 0) {
				return;
			}
			var file = Main.openImageFileInput.files[0];
			var fileReader = new FileReader();
			fileReader.onload = function(e1) {
				var image = new Image();
				image.onload = function(e2) {
					var canvas = _gthis1.imageToCanvas(image);
					while(canvas.width > _gthis1.maxInputImageSize || canvas.height > _gthis1.maxInputImageSize) canvas = CanvasTools.downScaleCanvas(canvas,0.5);
					_gthis1.targetImage = _gthis1.canvasToBitmap(canvas);
					_gthis1.onTargetImageChanged();
				};
				image.src = fileReader.result;
			};
			fileReader.readAsDataURL(file);
			Main.openImageFileInput.files[0] = null;
		},false);
		Main.stepButton.addEventListener("click",function() {
			_gthis1.stepRunner();
		},false);
		Main.resetButton.addEventListener("click",function() {
			_gthis1.targetImage = _gthis1.targetImage;
			_gthis1.onTargetImageChanged();
		},false);
		Main.saveImageButton.addEventListener("click",function(e3) {
			var svgData = "data:image/svg+xml;base64," + window.btoa(_gthis1.makeSvgData());
			var svgImage = new Image();
			svgImage.onload = function() {
				var canvas1 = _gthis1.imageToCanvas(svgImage);
				if(canvas1.msToBlob != null) {
					var blob = canvas1.msToBlob();
					var navigator = window.navigator;
					navigator.msSaveBlob(blob,"geometrized_image.png");
				} else {
					var data = canvas1.toDataURL("image/png").replace("image/png","image/octet-stream");
					var tempLink = window.document.createElement("a");
					tempLink.href = data;
					tempLink.download = "geometrized_image.png";
					window.document.body.appendChild(tempLink);
					tempLink.click();
					window.document.body.removeChild(tempLink);
				}
			};
			svgImage.setAttribute("src",svgData);
		},false);
		Main.saveSvgButton.addEventListener("click",function(e4) {
			var data1 = Main.currentSvgContainer.innerHTML;
			var svgBlob = new Blob([data1],{ type : "image/svg+xml;charset=utf-8"});
			var navigator1 = window.navigator;
			if(navigator1.msSaveBlob != null) {
				navigator1.msSaveBlob(svgBlob,"geometrized_svg.svg");
			} else {
				var svgUrl = URL.createObjectURL(svgBlob);
				Main.saveSvgButton.download = "geometrized_svg.svg";
				Main.saveSvgButton.href = svgUrl;
			}
		},false);
		var setShapeOption = function(option,enable) {
			if(enable) {
				geometrize__$ArraySet_ArraySet_$Impl_$.add(_gthis1.shapeTypes,option);
			} else {
				HxOverrides.remove(_gthis1.shapeTypes,option);
			}
		};
		Main.rectanglesCheckbox.addEventListener("click",function() {
			setShapeOption(0,Main.rectanglesCheckbox.checked);
		},false);
		Main.rotatedRectanglesCheckbox.addEventListener("click",function() {
			setShapeOption(1,Main.rotatedRectanglesCheckbox.checked);
		},false);
		Main.trianglesCheckbox.addEventListener("click",function() {
			setShapeOption(2,Main.trianglesCheckbox.checked);
		},false);
		Main.ellipsesCheckbox.addEventListener("click",function() {
			setShapeOption(3,Main.ellipsesCheckbox.checked);
		},false);
		Main.rotatedEllipsesCheckbox.addEventListener("click",function() {
			setShapeOption(4,Main.rotatedEllipsesCheckbox.checked);
		},false);
		Main.circlesCheckbox.addEventListener("click",function() {
			setShapeOption(5,Main.circlesCheckbox.checked);
		},false);
		Main.linesCheckbox.addEventListener("click",function() {
			setShapeOption(6,Main.linesCheckbox.checked);
		},false);
		this.set_maxShapeCountLimit(7000);
		this.worker.onMessage = $bind(this,this.onWorkerMessageReceived);
		this.targetImage = this.createDefaultBitmap();
		this.onTargetImageChanged();
		this.set_running(true);
	}
	,createTooltips: function(slider) {
		var tipHandles = slider.getElementsByClassName("noUi-handle");
		var _g1 = 0;
		var _g = tipHandles.length;
		while(_g1 < _g) {
			var i = _g1++;
			var div = window.document.createElement("div");
			div.className += "tooltip";
			tipHandles[i].appendChild(div);
			this.updateTooltips(slider,i,0);
		}
	}
	,updateTooltips: function(slider,handleIdx,value) {
		var tipHandles = slider.getElementsByClassName("noUi-handle");
		tipHandles[handleIdx].innerHTML = "<span class='tooltip'>" + (value == null ? "null" : "" + value) + "</span>";
	}
	,checkStopConditions: function() {
		if(this.get_shapeCount() >= this.get_maxShapeCountLimit()) {
			this.set_running(false);
		}
	}
	,stepRunner: function() {
		var options = { shapeTypes : this.shapeTypes.length == 0 ? [2] : geometrize__$ArraySet_ArraySet_$Impl_$.toArray(this.shapeTypes), alpha : this.shapeOpacity, candidateShapesPerStep : this.candidateShapesPerStep, shapeMutationsPerStep : this.shapeMutationsPerStep};
		this.worker.postMessage({ id : "should_step", data : options});
	}
	,onWorkerMessageReceived: function(message) {
		var _g = message.id;
		switch(_g) {
		case "did_set_target_image":
			break;
		case "did_step":
			var svgShapeData = message.data;
			this.appendShapeData(svgShapeData);
			this.checkStopConditions();
			break;
		}
		if(this.running) {
			this.stepRunner();
		}
	}
	,appendShapeData: function(data) {
		this.shapeData = this.shapeData.concat(data);
		var tmp = this.get_shapeCount();
		Main.shapesAddedText.innerHTML = Std.string(tmp);
		var data1 = this.makeSvgData();
		this.setSvgElement(data1);
	}
	,setSvgElement: function(svgCode) {
		Main.currentSvgContainer.innerHTML = svgCode;
	}
	,canvasToBitmap: function(canvas) {
		var context = canvas.getContext("2d",null);
		var imageData = context.getImageData(0,0,canvas.width,canvas.height);
		var bytesData = new haxe_io_Bytes(new ArrayBuffer(imageData.data.length));
		var _g1 = 0;
		var _g = bytesData.length;
		while(_g1 < _g) {
			var i = _g1++;
			bytesData.b[i] = imageData.data[i] & 255;
		}
		var w = canvas.width;
		var h = canvas.height;
		var bitmap = new geometrize_bitmap_Bitmap();
		if(!(bytesData != null)) {
			throw new js__$Boot_HaxeError("FAIL: bytes != null");
		}
		var actual = bytesData.length;
		var expected = w * h * 4;
		if(actual != expected) {
			throw new js__$Boot_HaxeError("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
		}
		bitmap.width = w;
		bitmap.height = h;
		var length = bytesData.length / 4 | 0;
		var this1 = new Array(length);
		bitmap.data = this1;
		var i1 = 0;
		var x = 0;
		while(i1 < bytesData.length) {
			var red = bytesData.b[i1];
			var green = bytesData.b[i1 + 1];
			var blue = bytesData.b[i1 + 2];
			var alpha = bytesData.b[i1 + 3];
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			bitmap.data[x] = ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
			i1 += 4;
			++x;
		}
		var bitmap1 = bitmap;
		return bitmap1;
	}
	,imageToCanvas: function(image) {
		var canvas = window.document.createElement("canvas");
		canvas.width = image.width;
		canvas.height = image.height;
		var context = canvas.getContext("2d",null);
		context.drawImage(image,0,0);
		return canvas;
	}
	,createDefaultBitmap: function() {
		return this.canvasToBitmap(this.imageToCanvas(Main.seagullImageElement));
	}
	,onTargetImageChanged: function() {
		var backgroundColor = geometrize_Util.getAverageImageColor(this.targetImage);
		this.shapeData = [];
		var backgroundRect = new geometrize_shape_Rectangle(this.targetImage.width,this.targetImage.height);
		backgroundRect.x1 = 0;
		backgroundRect.y1 = 0;
		backgroundRect.x2 = this.targetImage.width - 1;
		backgroundRect.y2 = this.targetImage.height - 1;
		this.appendShapeData([geometrize_exporter_SvgExporter.exportShape({ score : 0.0, color : backgroundColor, shape : backgroundRect})]);
		this.worker.postMessage({ id : "should_set_target_image", data : this.targetImage});
	}
	,makeSvgData: function() {
		return geometrize_exporter_SvgExporter.getSvgPrelude() + geometrize_exporter_SvgExporter.getSvgNodeOpen(this.targetImage.width,this.targetImage.height) + Std.string(this.shapeData) + geometrize_exporter_SvgExporter.getSvgNodeClose();
	}
	,set_running: function(running) {
		Main.runPauseButton.innerHTML = running ? "<h2>Pause</h2>" : "<h2>Run</h2>";
		var wasRunning = this.running;
		this.running = running;
		if(!wasRunning && this.running) {
			this.stepRunner();
		}
		return this.running;
	}
	,__class__: Main
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var geometrize__$ArraySet_ArraySet_$Impl_$ = {};
geometrize__$ArraySet_ArraySet_$Impl_$.__name__ = true;
geometrize__$ArraySet_ArraySet_$Impl_$.create = function(array) {
	if(array == null) {
		var this1 = [];
		return this1;
	}
	return geometrize__$ArraySet_ArraySet_$Impl_$.toSet(array);
};
geometrize__$ArraySet_ArraySet_$Impl_$.add = function(this1,element) {
	if(!(element != null)) {
		throw new js__$Boot_HaxeError("FAIL: element != null");
	}
	if(geometrize__$ArraySet_ArraySet_$Impl_$.contains(this1,element)) {
		return false;
	}
	this1.push(element);
	return true;
};
geometrize__$ArraySet_ArraySet_$Impl_$.contains = function(this1,element) {
	var _g = 0;
	while(_g < this1.length) {
		var i = this1[_g];
		++_g;
		if(i == element) {
			return true;
		}
	}
	return false;
};
geometrize__$ArraySet_ArraySet_$Impl_$.toArray = function(this1) {
	return this1.slice();
};
geometrize__$ArraySet_ArraySet_$Impl_$.toSet = function(array) {
	var this1 = [];
	var set = this1;
	var _g = 0;
	while(_g < array.length) {
		var v = array[_g];
		++_g;
		geometrize__$ArraySet_ArraySet_$Impl_$.add(set,v);
	}
	return set;
};
var geometrize_Util = function() { };
geometrize_Util.__name__ = true;
geometrize_Util.getAverageImageColor = function(image) {
	if(!(image != null)) {
		throw new js__$Boot_HaxeError("FAIL: image != null");
	}
	var totalRed = 0;
	var totalGreen = 0;
	var totalBlue = 0;
	var _g1 = 0;
	var _g = image.width;
	while(_g1 < _g) {
		var x = _g1++;
		var _g3 = 0;
		var _g2 = image.height;
		while(_g3 < _g2) {
			var y = _g3++;
			var pixel = image.data[image.width * y + x];
			totalRed += pixel >> 24 & 255;
			totalGreen += pixel >> 16 & 255;
			totalBlue += pixel >> 8 & 255;
		}
	}
	var size = image.width * image.height;
	var red = totalRed / size | 0;
	var green = totalGreen / size | 0;
	var blue = totalBlue / size | 0;
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	return ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + 255;
};
var geometrize_bitmap_Bitmap = function() {
};
geometrize_bitmap_Bitmap.__name__ = true;
geometrize_bitmap_Bitmap.prototype = {
	__class__: geometrize_bitmap_Bitmap
};
var geometrize_exporter_SvgExporter = function() { };
geometrize_exporter_SvgExporter.__name__ = true;
geometrize_exporter_SvgExporter.exportShape = function(shape) {
	return StringTools.replace(shape.shape.getSvgShapeData(),geometrize_exporter_SvgExporter.SVG_STYLE_HOOK,geometrize_exporter_SvgExporter.stylesForShape(shape));
};
geometrize_exporter_SvgExporter.getSvgPrelude = function() {
	return "<?xml version=\"1.0\" standalone=\"no\"?>\n";
};
geometrize_exporter_SvgExporter.getSvgNodeOpen = function(width,height) {
	return "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.2\" baseProfile=\"tiny\" width=\"" + width + "\" height=\"" + height + "\">\n";
};
geometrize_exporter_SvgExporter.getSvgNodeClose = function() {
	return "</svg>";
};
geometrize_exporter_SvgExporter.stylesForShape = function(shape) {
	var _g = shape.shape.getType();
	if(_g == 6) {
		return geometrize_exporter_SvgExporter.strokeForColor(shape.color) + " stroke-width=\"1\" fill=\"none\" " + geometrize_exporter_SvgExporter.strokeOpacityForAlpha(shape.color & 255);
	} else {
		return geometrize_exporter_SvgExporter.fillForColor(shape.color) + " " + geometrize_exporter_SvgExporter.fillOpacityForAlpha(shape.color & 255);
	}
};
geometrize_exporter_SvgExporter.rgbForColor = function(color) {
	return "rgb(" + (color >> 24 & 255) + "," + (color >> 16 & 255) + "," + (color >> 8 & 255) + ")";
};
geometrize_exporter_SvgExporter.strokeForColor = function(color) {
	return "stroke=\"" + geometrize_exporter_SvgExporter.rgbForColor(color) + "\"";
};
geometrize_exporter_SvgExporter.fillForColor = function(color) {
	return "fill=\"" + geometrize_exporter_SvgExporter.rgbForColor(color) + "\"";
};
geometrize_exporter_SvgExporter.fillOpacityForAlpha = function(alpha) {
	return "fill-opacity=\"" + alpha / 255.0 + "\"";
};
geometrize_exporter_SvgExporter.strokeOpacityForAlpha = function(alpha) {
	return "stroke-opacity=\"" + alpha / 255.0 + "\"";
};
var geometrize_shape_Shape = function() { };
geometrize_shape_Shape.__name__ = true;
geometrize_shape_Shape.prototype = {
	__class__: geometrize_shape_Shape
};
var geometrize_shape_Rectangle = function(xBound,yBound) {
	this.x1 = Std.random(xBound);
	this.y1 = Std.random(yBound);
	var value = this.x1 + Std.random(32) + 1;
	var max = xBound - 1;
	if(!(0 <= max)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	this.x2 = value < 0 ? 0 : value > max ? max : value;
	var value1 = this.y1 + Std.random(32) + 1;
	var max1 = yBound - 1;
	if(!(0 <= max1)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	this.y2 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
	this.xBound = xBound;
	this.yBound = yBound;
};
geometrize_shape_Rectangle.__name__ = true;
geometrize_shape_Rectangle.__interfaces__ = [geometrize_shape_Shape];
geometrize_shape_Rectangle.prototype = {
	getType: function() {
		return 0;
	}
	,getSvgShapeData: function() {
		var first = this.x1;
		var second = this.x2;
		var first1 = this.y1;
		var second1 = this.y2;
		var first2 = this.x1;
		var second2 = this.x2;
		var first3 = this.x1;
		var second3 = this.x2;
		var first4 = this.y1;
		var second4 = this.y2;
		var first5 = this.y1;
		var second5 = this.y2;
		return "<rect x=\"" + (first < second ? first : second) + "\" y=\"" + (first1 < second1 ? first1 : second1) + "\" width=\"" + ((first2 > second2 ? first2 : second2) - (first3 < second3 ? first3 : second3)) + "\" height=\"" + ((first4 > second4 ? first4 : second4) - (first5 < second5 ? first5 : second5)) + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
	}
	,__class__: geometrize_shape_Rectangle
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.prototype = {
	__class__: haxe_io_Bytes
};
var haxe_io_FPHelper = function() { };
haxe_io_FPHelper.__name__ = true;
haxe_io_FPHelper.i32ToFloat = function(i) {
	var sign = 1 - (i >>> 31 << 1);
	var exp = i >>> 23 & 255;
	var sig = i & 8388607;
	if(sig == 0 && exp == 0) {
		return 0.0;
	}
	return sign * (1 + Math.pow(2,-23) * sig) * Math.pow(2,exp - 127);
};
haxe_io_FPHelper.floatToI32 = function(f) {
	if(f == 0) {
		return 0;
	}
	var af = f < 0 ? -f : f;
	var exp = Math.floor(Math.log(af) / 0.6931471805599453);
	if(exp < -127) {
		exp = -127;
	} else if(exp > 128) {
		exp = 128;
	}
	var sig = Math.round((af / Math.pow(2,exp) - 1) * 8388608);
	if(sig == 8388608 && exp < 128) {
		sig = 0;
		++exp;
	}
	return (f < 0 ? -2147483648 : 0) | exp + 127 << 23 | sig;
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = _g1++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_html_compat_ArrayBuffer = function(a) {
	if((a instanceof Array) && a.__enum__ == null) {
		this.a = a;
		this.byteLength = a.length;
	} else {
		var len = a;
		this.a = [];
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) {
			var i = _g1++;
			this.a[i] = 0;
		}
		this.byteLength = len;
	}
};
js_html_compat_ArrayBuffer.__name__ = true;
js_html_compat_ArrayBuffer.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var result = new ArrayBuffer(u.byteLength);
	var resultArray = new Uint8Array(result);
	resultArray.set(u);
	return result;
};
js_html_compat_ArrayBuffer.prototype = {
	slice: function(begin,end) {
		return new js_html_compat_ArrayBuffer(this.a.slice(begin,end));
	}
	,__class__: js_html_compat_ArrayBuffer
};
var js_html_compat_Float32Array = function() { };
js_html_compat_Float32Array.__name__ = true;
js_html_compat_Float32Array._new = function(arg1,offset,length) {
	var arr;
	if(typeof(arg1) == "number") {
		arr = [];
		var _g1 = 0;
		var _g = arg1;
		while(_g1 < _g) {
			var i = _g1++;
			arr[i] = 0;
		}
		arr.byteLength = arr.length << 2;
		arr.byteOffset = 0;
		var _g2 = [];
		var _g21 = 0;
		var _g11 = arr.length << 2;
		while(_g21 < _g11) {
			var i1 = _g21++;
			_g2.push(0);
		}
		arr.buffer = new js_html_compat_ArrayBuffer(_g2);
	} else if(js_Boot.__instanceof(arg1,js_html_compat_ArrayBuffer)) {
		var buffer = arg1;
		if(offset == null) {
			offset = 0;
		}
		if(length == null) {
			length = buffer.byteLength - offset >> 2;
		}
		arr = [];
		var _g12 = 0;
		var _g3 = length;
		while(_g12 < _g3) {
			var i2 = _g12++;
			var val = buffer.a[offset++] | buffer.a[offset++] << 8 | buffer.a[offset++] << 16 | buffer.a[offset++] << 24;
			arr.push(haxe_io_FPHelper.i32ToFloat(val));
		}
		arr.byteLength = arr.length << 2;
		arr.byteOffset = offset;
		arr.buffer = buffer;
	} else if((arg1 instanceof Array) && arg1.__enum__ == null) {
		arr = arg1.slice();
		var buffer1 = [];
		var _g4 = 0;
		while(_g4 < arr.length) {
			var f = arr[_g4];
			++_g4;
			var i3 = haxe_io_FPHelper.floatToI32(f);
			buffer1.push(i3 & 255);
			buffer1.push(i3 >> 8 & 255);
			buffer1.push(i3 >> 16 & 255);
			buffer1.push(i3 >>> 24);
		}
		arr.byteLength = arr.length << 2;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(buffer1);
	} else {
		throw new js__$Boot_HaxeError("TODO " + Std.string(arg1));
	}
	arr.subarray = js_html_compat_Float32Array._subarray;
	arr.set = js_html_compat_Float32Array._set;
	return arr;
};
js_html_compat_Float32Array._set = function(arg,offset) {
	if(js_Boot.__instanceof(arg.buffer,js_html_compat_ArrayBuffer)) {
		var a = arg;
		if(arg.byteLength + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g1 = 0;
		var _g = arg.byteLength;
		while(_g1 < _g) {
			var i = _g1++;
			this[i + offset] = a[i];
		}
	} else if((arg instanceof Array) && arg.__enum__ == null) {
		var a1 = arg;
		if(a1.length + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g11 = 0;
		var _g2 = a1.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			this[i1 + offset] = a1[i1];
		}
	} else {
		throw new js__$Boot_HaxeError("TODO");
	}
};
js_html_compat_Float32Array._subarray = function(start,end) {
	var a = js_html_compat_Float32Array._new(this.slice(start,end));
	a.byteOffset = start * 4;
	return a;
};
var js_html_compat_Uint8Array = function() { };
js_html_compat_Uint8Array.__name__ = true;
js_html_compat_Uint8Array._new = function(arg1,offset,length) {
	var arr;
	if(typeof(arg1) == "number") {
		arr = [];
		var _g1 = 0;
		var _g = arg1;
		while(_g1 < _g) {
			var i = _g1++;
			arr[i] = 0;
		}
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else if(js_Boot.__instanceof(arg1,js_html_compat_ArrayBuffer)) {
		var buffer = arg1;
		if(offset == null) {
			offset = 0;
		}
		if(length == null) {
			length = buffer.byteLength - offset;
		}
		if(offset == 0) {
			arr = buffer.a;
		} else {
			arr = buffer.a.slice(offset,offset + length);
		}
		arr.byteLength = arr.length;
		arr.byteOffset = offset;
		arr.buffer = buffer;
	} else if((arg1 instanceof Array) && arg1.__enum__ == null) {
		arr = arg1.slice();
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else {
		throw new js__$Boot_HaxeError("TODO " + Std.string(arg1));
	}
	arr.subarray = js_html_compat_Uint8Array._subarray;
	arr.set = js_html_compat_Uint8Array._set;
	return arr;
};
js_html_compat_Uint8Array._set = function(arg,offset) {
	if(js_Boot.__instanceof(arg.buffer,js_html_compat_ArrayBuffer)) {
		var a = arg;
		if(arg.byteLength + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g1 = 0;
		var _g = arg.byteLength;
		while(_g1 < _g) {
			var i = _g1++;
			this[i + offset] = a[i];
		}
	} else if((arg instanceof Array) && arg.__enum__ == null) {
		var a1 = arg;
		if(a1.length + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g11 = 0;
		var _g2 = a1.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			this[i1 + offset] = a1[i1];
		}
	} else {
		throw new js__$Boot_HaxeError("TODO");
	}
};
js_html_compat_Uint8Array._subarray = function(start,end) {
	var a = js_html_compat_Uint8Array._new(this.slice(start,end));
	a.byteOffset = start;
	return a;
};
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
var Int = { __name__ : ["Int"]};
var Dynamic = { __name__ : ["Dynamic"]};
var Float = Number;
Float.__name__ = ["Float"];
var Bool = Boolean;
Bool.__ename__ = ["Bool"];
var Class = { __name__ : ["Class"]};
var Enum = { };
var ArrayBuffer = $global.ArrayBuffer || js_html_compat_ArrayBuffer;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_html_compat_ArrayBuffer.sliceImpl;
}
var Float32Array = $global.Float32Array || js_html_compat_Float32Array._new;
var Uint8Array = $global.Uint8Array || js_html_compat_Uint8Array._new;
Main.runPauseButton = window.document.getElementById("runpausebutton");
Main.stepButton = window.document.getElementById("stepbutton");
Main.openImageFileInput = window.document.getElementById("openimageinput");
Main.resetButton = window.document.getElementById("resetbutton");
Main.saveImageButton = window.document.getElementById("saveimagebutton");
Main.saveSvgButton = window.document.getElementById("savesvgbutton");
Main.rectanglesCheckbox = window.document.getElementById("rectangles");
Main.rotatedRectanglesCheckbox = window.document.getElementById("rotatedrectangles");
Main.trianglesCheckbox = window.document.getElementById("triangles");
Main.ellipsesCheckbox = window.document.getElementById("ellipses");
Main.rotatedEllipsesCheckbox = window.document.getElementById("rotatedellipses");
Main.circlesCheckbox = window.document.getElementById("circles");
Main.linesCheckbox = window.document.getElementById("lines");
Main.shapeOpacitySlider = window.document.getElementById("shapeopacity");
Main.randomShapesPerStepSlider = window.document.getElementById("randomshapesperstep");
Main.shapeMutationsPerStepSlider = window.document.getElementById("shapemutationsperstep");
Main.shapesAddedText = window.document.getElementById("shapesaddedtext");
Main.maxShapesCapTextEdit = window.document.getElementById("maxshapescaptextedit");
Main.seagullImageElement = window.document.getElementById("defaultimage");
Main.currentSvgContainer = window.document.getElementById("currentsvgcontainer");
geometrize_exporter_SvgExporter.SVG_STYLE_HOOK = "::svg_style_hook::";
js_Boot.__toStr = ({ }).toString;
js_html_compat_Float32Array.BYTES_PER_ELEMENT = 4;
js_html_compat_Uint8Array.BYTES_PER_ELEMENT = 1;
Main.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
