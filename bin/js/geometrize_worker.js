// Generated by Haxe 3.4.7
(function () { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var GeometrizeWorker = function() { };
GeometrizeWorker.prototype = {
	messageHandler: function(event) {
		if(event == null || event.data == null) {
			return;
		}
		var message = event.data;
		var _g = message.id;
		switch(_g) {
		case "should_set_target_image":
			var target = message.data;
			this.runner = new geometrize_runner_ImageRunner(target,geometrize_Util.getAverageImageColor(target));
			this.postMessage({ id : "did_set_target_image", data : null});
			break;
		case "should_step":
			var options = message.data;
			var results = this.runner.step(options);
			var svgData = geometrize_exporter_SvgExporter.exportShapes(results);
			this.postMessage({ id : "did_step", data : svgData});
			break;
		}
	}
	,postMessage: function(message) {
	}
};
var HxOverrides = function() { };
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Std = function() { };
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringTools = function() { };
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var _$UInt_UInt_$Impl_$ = {};
_$UInt_UInt_$Impl_$.toFloat = function(this1) {
	var $int = this1;
	if($int < 0) {
		return 4294967296.0 + $int;
	} else {
		return $int + 0.0;
	}
};
var geometrize__$ArraySet_ArraySet_$Impl_$ = {};
geometrize__$ArraySet_ArraySet_$Impl_$.create = function(array) {
	if(array == null) {
		var this1 = [];
		return this1;
	}
	return geometrize__$ArraySet_ArraySet_$Impl_$.toSet(array);
};
geometrize__$ArraySet_ArraySet_$Impl_$.add = function(this1,element) {
	if(!(element != null)) {
		throw new js__$Boot_HaxeError("FAIL: element != null");
	}
	if(geometrize__$ArraySet_ArraySet_$Impl_$.contains(this1,element)) {
		return false;
	}
	this1.push(element);
	return true;
};
geometrize__$ArraySet_ArraySet_$Impl_$.contains = function(this1,element) {
	var _g = 0;
	while(_g < this1.length) {
		var i = this1[_g];
		++_g;
		if(i == element) {
			return true;
		}
	}
	return false;
};
geometrize__$ArraySet_ArraySet_$Impl_$.toArray = function(this1) {
	return this1.slice();
};
geometrize__$ArraySet_ArraySet_$Impl_$.toSet = function(array) {
	var this1 = [];
	var set = this1;
	var _g = 0;
	while(_g < array.length) {
		var v = array[_g];
		++_g;
		geometrize__$ArraySet_ArraySet_$Impl_$.add(set,v);
	}
	return set;
};
var geometrize_Core = function() { };
geometrize_Core.computeColor = function(target,current,lines,alpha) {
	if(!(target != null)) {
		throw new js__$Boot_HaxeError("FAIL: target != null");
	}
	if(!(current != null)) {
		throw new js__$Boot_HaxeError("FAIL: current != null");
	}
	if(!(lines != null)) {
		throw new js__$Boot_HaxeError("FAIL: lines != null");
	}
	if(!(alpha >= 0)) {
		throw new js__$Boot_HaxeError("FAIL: alpha >= 0");
	}
	var totalRed = 0;
	var totalGreen = 0;
	var totalBlue = 0;
	var count = 0;
	var f = 65535 / alpha;
	var a = f | 0;
	var _g = 0;
	while(_g < lines.length) {
		var line = lines[_g];
		++_g;
		var y = line.y;
		var _g2 = line.x1;
		var _g1 = line.x2 + 1;
		while(_g2 < _g1) {
			var x = _g2++;
			var t = target.data[target.width * y + x];
			var c = current.data[current.width * y + x];
			totalRed += ((t >> 24 & 255) - (c >> 24 & 255)) * a + (c >> 24 & 255) * 257;
			totalGreen += ((t >> 16 & 255) - (c >> 16 & 255)) * a + (c >> 16 & 255) * 257;
			totalBlue += ((t >> 8 & 255) - (c >> 8 & 255)) * a + (c >> 8 & 255) * 257;
			++count;
		}
	}
	if(count == 0) {
		return 0;
	}
	var value = (totalRed / count | 0) >> 8;
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	var r = value < 0 ? 0 : value > 255 ? 255 : value;
	var value1 = (totalGreen / count | 0) >> 8;
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	var g = value1 < 0 ? 0 : value1 > 255 ? 255 : value1;
	var value2 = (totalBlue / count | 0) >> 8;
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	var b = value2 < 0 ? 0 : value2 > 255 ? 255 : value2;
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	return ((r < 0 ? 0 : r > 255 ? 255 : r) << 24) + ((g < 0 ? 0 : g > 255 ? 255 : g) << 16) + ((b < 0 ? 0 : b > 255 ? 255 : b) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
};
geometrize_Core.differenceFull = function(first,second) {
	if(!(first != null)) {
		throw new js__$Boot_HaxeError("FAIL: first != null");
	}
	if(!(second != null)) {
		throw new js__$Boot_HaxeError("FAIL: second != null");
	}
	var actual = first.width;
	var expected = second.width;
	if(actual != expected) {
		throw new js__$Boot_HaxeError("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
	}
	var actual1 = first.height;
	var expected1 = second.height;
	if(actual1 != expected1) {
		throw new js__$Boot_HaxeError("FAIL: values are not equal (expected: " + expected1 + ", actual: " + actual1 + ")");
	}
	var total = 0;
	var width = first.width;
	var height = first.height;
	var _g1 = 0;
	var _g = height;
	while(_g1 < _g) {
		var y = _g1++;
		var _g3 = 0;
		var _g2 = width;
		while(_g3 < _g2) {
			var x = _g3++;
			var f = first.data[first.width * y + x];
			var s = second.data[second.width * y + x];
			var dr = (f >> 24 & 255) - (s >> 24 & 255);
			var dg = (f >> 16 & 255) - (s >> 16 & 255);
			var db = (f >> 8 & 255) - (s >> 8 & 255);
			var da = (f & 255) - (s & 255);
			total += dr * dr + dg * dg + db * db + da * da;
		}
	}
	return Math.sqrt(total / (width * height * 4.0)) / 255;
};
geometrize_Core.differencePartial = function(target,before,after,score,lines) {
	if(!(target != null)) {
		throw new js__$Boot_HaxeError("FAIL: target != null");
	}
	if(!(before != null)) {
		throw new js__$Boot_HaxeError("FAIL: before != null");
	}
	if(!(after != null)) {
		throw new js__$Boot_HaxeError("FAIL: after != null");
	}
	if(!(lines != null)) {
		throw new js__$Boot_HaxeError("FAIL: lines != null");
	}
	var width = target.width;
	var height = target.height;
	var rgbaCount = width * height * 4;
	var total = Math.pow(score * 255,2) * rgbaCount;
	var _g = 0;
	while(_g < lines.length) {
		var line = lines[_g];
		++_g;
		var y = line.y;
		var _g2 = line.x1;
		var _g1 = line.x2 + 1;
		while(_g2 < _g1) {
			var x = _g2++;
			var t = target.data[target.width * y + x];
			var b = before.data[before.width * y + x];
			var a = after.data[after.width * y + x];
			var dtbr = (t >> 24 & 255) - (b >> 24 & 255);
			var dtbg = (t >> 16 & 255) - (b >> 16 & 255);
			var dtbb = (t >> 8 & 255) - (b >> 8 & 255);
			var dtba = (t & 255) - (b & 255);
			var dtar = (t >> 24 & 255) - (a >> 24 & 255);
			var dtag = (t >> 16 & 255) - (a >> 16 & 255);
			var dtab = (t >> 8 & 255) - (a >> 8 & 255);
			var dtaa = (t & 255) - (a & 255);
			total -= dtbr * dtbr + dtbg * dtbg + dtbb * dtbb + dtba * dtba;
			total += dtar * dtar + dtag * dtag + dtab * dtab + dtaa * dtaa;
		}
	}
	return Math.sqrt(total / rgbaCount) / 255;
};
geometrize_Core.bestRandomState = function(shapes,alpha,n,target,current,buffer,lastScore) {
	var bestEnergy = 0;
	var bestState = null;
	var _g1 = 0;
	var _g = n;
	while(_g1 < _g) {
		var i = _g1++;
		var state = new geometrize_State(geometrize_shape_ShapeFactory.randomShapeOf(shapes,current.width,current.height),alpha,target,current,buffer);
		var energy = state.energy(lastScore);
		if(i == 0 || energy < bestEnergy) {
			bestEnergy = energy;
			bestState = state;
		}
	}
	return bestState;
};
geometrize_Core.bestHillClimbState = function(shapes,alpha,n,age,target,current,buffer,lastScore) {
	var state = geometrize_Core.bestRandomState(shapes,alpha,n,target,current,buffer,lastScore);
	state = geometrize_Core.hillClimb(state,age,lastScore);
	return state;
};
geometrize_Core.hillClimb = function(state,maxAge,lastScore) {
	if(!(state != null)) {
		throw new js__$Boot_HaxeError("FAIL: state != null");
	}
	if(!(maxAge >= 0)) {
		throw new js__$Boot_HaxeError("FAIL: maxAge >= 0");
	}
	var state1 = state.clone();
	var bestState = state1.clone();
	var bestEnergy = state1.energy(lastScore);
	var age = 0;
	while(age < maxAge) {
		var undo = state1.mutate();
		var energy = state1.energy(lastScore);
		if(energy >= bestEnergy) {
			state1 = undo;
		} else {
			bestEnergy = energy;
			bestState = state1.clone();
			age = -1;
		}
		++age;
	}
	return bestState;
};
geometrize_Core.energy = function(shape,alpha,target,current,buffer,score) {
	if(!(shape != null)) {
		throw new js__$Boot_HaxeError("FAIL: shape != null");
	}
	if(!(target != null)) {
		throw new js__$Boot_HaxeError("FAIL: target != null");
	}
	if(!(current != null)) {
		throw new js__$Boot_HaxeError("FAIL: current != null");
	}
	if(!(buffer != null)) {
		throw new js__$Boot_HaxeError("FAIL: buffer != null");
	}
	var lines = shape.rasterize();
	var color = geometrize_Core.computeColor(target,current,lines,alpha);
	geometrize_rasterizer_Rasterizer.copyLines(buffer,current,lines);
	geometrize_rasterizer_Rasterizer.drawLines(buffer,color,lines);
	return geometrize_Core.differencePartial(target,current,buffer,score,lines);
};
var geometrize_Model = function(target,backgroundColor) {
	if(!(target != null)) {
		throw new js__$Boot_HaxeError("FAIL: target != null");
	}
	this.width = target.width;
	this.height = target.height;
	this.target = target;
	var w = target.width;
	var h = target.height;
	var bitmap = new geometrize_bitmap_Bitmap();
	bitmap.width = w;
	bitmap.height = h;
	var this1 = new Array(w * h);
	bitmap.data = this1;
	var i = 0;
	while(i < bitmap.data.length) {
		bitmap.data[i] = backgroundColor;
		++i;
	}
	this.current = bitmap;
	var w1 = target.width;
	var h1 = target.height;
	var bitmap1 = new geometrize_bitmap_Bitmap();
	bitmap1.width = w1;
	bitmap1.height = h1;
	var this2 = new Array(w1 * h1);
	bitmap1.data = this2;
	var i1 = 0;
	while(i1 < bitmap1.data.length) {
		bitmap1.data[i1] = backgroundColor;
		++i1;
	}
	this.buffer = bitmap1;
	this.score = geometrize_Core.differenceFull(target,this.current);
};
geometrize_Model.prototype = {
	step: function(shapeTypes,alpha,n,age) {
		var state = geometrize_Core.bestHillClimbState(shapeTypes,alpha,n,age,this.target,this.current,this.buffer,this.score);
		var results = [this.addShape(state.shape,state.alpha)];
		return results;
	}
	,addShape: function(shape,alpha) {
		if(!(shape != null)) {
			throw new js__$Boot_HaxeError("FAIL: shape != null");
		}
		var _this = this.current;
		var bitmap = new geometrize_bitmap_Bitmap();
		bitmap.width = _this.width;
		bitmap.height = _this.height;
		var length = _this.data.length;
		var this1 = new Array(length);
		bitmap.data = this1;
		var _g1 = 0;
		var _g = _this.data.length;
		while(_g1 < _g) {
			var i = _g1++;
			bitmap.data[i] = _this.data[i];
		}
		var before = bitmap;
		var lines = shape.rasterize();
		var color = geometrize_Core.computeColor(this.target,this.current,lines,alpha);
		geometrize_rasterizer_Rasterizer.drawLines(this.current,color,lines);
		this.score = geometrize_Core.differencePartial(this.target,before,this.current,this.score,lines);
		var result = { score : this.score, color : color, shape : shape};
		return result;
	}
};
var geometrize_State = function(shape,alpha,target,current,buffer) {
	if(!(shape != null)) {
		throw new js__$Boot_HaxeError("FAIL: shape != null");
	}
	this.shape = shape;
	this.alpha = alpha;
	this.score = -1;
	this.target = target;
	this.current = current;
	this.buffer = buffer;
};
geometrize_State.prototype = {
	energy: function(lastScore) {
		if(this.score < 0) {
			this.score = geometrize_Core.energy(this.shape,this.alpha,this.target,this.current,this.buffer,lastScore);
		}
		return this.score;
	}
	,mutate: function() {
		var oldState = this.clone();
		this.shape.mutate();
		return oldState;
	}
	,clone: function() {
		return new geometrize_State(this.shape.clone(),this.alpha,this.target,this.current,this.buffer);
	}
};
var geometrize_Util = function() { };
geometrize_Util.getAverageImageColor = function(image) {
	if(!(image != null)) {
		throw new js__$Boot_HaxeError("FAIL: image != null");
	}
	var totalRed = 0;
	var totalGreen = 0;
	var totalBlue = 0;
	var _g1 = 0;
	var _g = image.width;
	while(_g1 < _g) {
		var x = _g1++;
		var _g3 = 0;
		var _g2 = image.height;
		while(_g3 < _g2) {
			var y = _g3++;
			var pixel = image.data[image.width * y + x];
			totalRed += pixel >> 24 & 255;
			totalGreen += pixel >> 16 & 255;
			totalBlue += pixel >> 8 & 255;
		}
	}
	var size = image.width * image.height;
	var red = totalRed / size | 0;
	var green = totalGreen / size | 0;
	var blue = totalBlue / size | 0;
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	return ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + 255;
};
var geometrize_bitmap_Bitmap = function() {
};
var geometrize_exporter_SvgExporter = function() { };
geometrize_exporter_SvgExporter.exportShapes = function(shapes) {
	var results = "";
	var _g1 = 0;
	var _g = shapes.length;
	while(_g1 < _g) {
		var i = _g1++;
		results += geometrize_exporter_SvgExporter.exportShape(shapes[i]);
		if(i != shapes.length - 1) {
			results += "\n";
		}
	}
	return results;
};
geometrize_exporter_SvgExporter.exportShape = function(shape) {
	return StringTools.replace(shape.shape.getSvgShapeData(),geometrize_exporter_SvgExporter.SVG_STYLE_HOOK,geometrize_exporter_SvgExporter.stylesForShape(shape));
};
geometrize_exporter_SvgExporter.stylesForShape = function(shape) {
	var _g = shape.shape.getType();
	if(_g == 6) {
		return geometrize_exporter_SvgExporter.strokeForColor(shape.color) + " stroke-width=\"1\" fill=\"none\" " + geometrize_exporter_SvgExporter.strokeOpacityForAlpha(shape.color & 255);
	} else {
		return geometrize_exporter_SvgExporter.fillForColor(shape.color) + " " + geometrize_exporter_SvgExporter.fillOpacityForAlpha(shape.color & 255);
	}
};
geometrize_exporter_SvgExporter.rgbForColor = function(color) {
	return "rgb(" + (color >> 24 & 255) + "," + (color >> 16 & 255) + "," + (color >> 8 & 255) + ")";
};
geometrize_exporter_SvgExporter.strokeForColor = function(color) {
	return "stroke=\"" + geometrize_exporter_SvgExporter.rgbForColor(color) + "\"";
};
geometrize_exporter_SvgExporter.fillForColor = function(color) {
	return "fill=\"" + geometrize_exporter_SvgExporter.rgbForColor(color) + "\"";
};
geometrize_exporter_SvgExporter.fillOpacityForAlpha = function(alpha) {
	return "fill-opacity=\"" + alpha / 255.0 + "\"";
};
geometrize_exporter_SvgExporter.strokeOpacityForAlpha = function(alpha) {
	return "stroke-opacity=\"" + alpha / 255.0 + "\"";
};
var geometrize_rasterizer_Rasterizer = function() { };
geometrize_rasterizer_Rasterizer.drawLines = function(image,c,lines) {
	if(!(image != null)) {
		throw new js__$Boot_HaxeError("FAIL: image != null");
	}
	if(!(lines != null)) {
		throw new js__$Boot_HaxeError("FAIL: lines != null");
	}
	var sr = c >> 24 & 255;
	sr |= sr << 8;
	sr *= c & 255;
	sr = sr / 255 | 0;
	var sg = c >> 16 & 255;
	sg |= sg << 8;
	sg *= c & 255;
	sg = sg / 255 | 0;
	var sb = c >> 8 & 255;
	sb |= sb << 8;
	sb *= c & 255;
	sb = sb / 255 | 0;
	var sa = c & 255;
	sa |= sa << 8;
	var _g = 0;
	while(_g < lines.length) {
		var line = lines[_g];
		++_g;
		var y = line.y;
		var ma = 65535;
		var m = 65535;
		var $as = (m - sa * (ma / m)) * 257;
		var a = $as | 0;
		var _g2 = line.x1;
		var _g1 = line.x2 + 1;
		while(_g2 < _g1) {
			var x = _g2++;
			var d = image.data[image.width * y + x];
			var dr = d >> 24 & 255;
			var dg = d >> 16 & 255;
			var db = d >> 8 & 255;
			var da = d & 255;
			var r = (_$UInt_UInt_$Impl_$.toFloat(dr * a + sr * ma) / _$UInt_UInt_$Impl_$.toFloat(m) | 0) >> 8;
			var g = (_$UInt_UInt_$Impl_$.toFloat(dg * a + sg * ma) / _$UInt_UInt_$Impl_$.toFloat(m) | 0) >> 8;
			var b = (_$UInt_UInt_$Impl_$.toFloat(db * a + sb * ma) / _$UInt_UInt_$Impl_$.toFloat(m) | 0) >> 8;
			var a1 = (_$UInt_UInt_$Impl_$.toFloat(da * a + sa * ma) / _$UInt_UInt_$Impl_$.toFloat(m) | 0) >> 8;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			image.data[image.width * y + x] = ((r < 0 ? 0 : r > 255 ? 255 : r) << 24) + ((g < 0 ? 0 : g > 255 ? 255 : g) << 16) + ((b < 0 ? 0 : b > 255 ? 255 : b) << 8) + (a1 < 0 ? 0 : a1 > 255 ? 255 : a1);
		}
	}
};
geometrize_rasterizer_Rasterizer.copyLines = function(destination,source,lines) {
	if(!(destination != null)) {
		throw new js__$Boot_HaxeError("FAIL: destination != null");
	}
	if(!(source != null)) {
		throw new js__$Boot_HaxeError("FAIL: source != null");
	}
	if(!(lines != null)) {
		throw new js__$Boot_HaxeError("FAIL: lines != null");
	}
	var _g = 0;
	while(_g < lines.length) {
		var line = lines[_g];
		++_g;
		var y = line.y;
		var _g2 = line.x1;
		var _g1 = line.x2 + 1;
		while(_g2 < _g1) {
			var x = _g2++;
			destination.data[destination.width * y + x] = source.data[source.width * y + x];
		}
	}
};
geometrize_rasterizer_Rasterizer.bresenham = function(x1,y1,x2,y2) {
	var dx = x2 - x1;
	var ix = (dx > 0 ? 1 : 0) - (dx < 0 ? 1 : 0);
	dx = (dx < 0 ? -dx : dx) << 1;
	var dy = y2 - y1;
	var iy = (dy > 0 ? 1 : 0) - (dy < 0 ? 1 : 0);
	dy = (dy < 0 ? -dy : dy) << 1;
	var points = [];
	points.push({ x : x1, y : y1});
	if(dx >= dy) {
		var error = dy - (dx >> 1);
		while(x1 != x2) {
			if(error >= 0 && (error != 0 || ix > 0)) {
				error -= dx;
				y1 += iy;
			}
			error += dy;
			x1 += ix;
			points.push({ x : x1, y : y1});
		}
	} else {
		var error1 = dx - (dy >> 1);
		while(y1 != y2) {
			if(error1 >= 0 && (error1 != 0 || iy > 0)) {
				error1 -= dy;
				x1 += ix;
			}
			error1 += dx;
			y1 += iy;
			points.push({ x : x1, y : y1});
		}
	}
	return points;
};
geometrize_rasterizer_Rasterizer.scanlinesForPolygon = function(points) {
	var lines = [];
	var edges = [];
	var _g1 = 0;
	var _g = points.length;
	while(_g1 < _g) {
		var i = _g1++;
		var p1 = points[i];
		var p2 = i == points.length - 1 ? points[0] : points[i + 1];
		var p1p2 = geometrize_rasterizer_Rasterizer.bresenham(p1.x,p1.y,p2.x,p2.y);
		edges = edges.concat(p1p2);
	}
	var yToXs = new haxe_ds_IntMap();
	var _g2 = 0;
	while(_g2 < edges.length) {
		var point = edges[_g2];
		++_g2;
		var s = yToXs.h[point.y];
		if(s != null) {
			geometrize__$ArraySet_ArraySet_$Impl_$.add(s,point.x);
		} else {
			s = geometrize__$ArraySet_ArraySet_$Impl_$.create();
			geometrize__$ArraySet_ArraySet_$Impl_$.add(s,point.x);
			yToXs.h[point.y] = s;
		}
	}
	var key = yToXs.keys();
	while(key.hasNext()) {
		var key1 = key.next();
		var a = geometrize__$ArraySet_ArraySet_$Impl_$.toArray(yToXs.h[key1]);
		var minMaxElements;
		if(a == null || a.length == 0) {
			minMaxElements = { x : 0, y : 0};
		} else {
			var min = a[0];
			var max = a[0];
			var _g3 = 0;
			while(_g3 < a.length) {
				var value = a[_g3];
				++_g3;
				if(min > value) {
					min = value;
				}
				if(max < value) {
					max = value;
				}
			}
			minMaxElements = { x : min, y : max};
		}
		lines.push(new geometrize_rasterizer_Scanline(key1,minMaxElements.x,minMaxElements.y));
	}
	return lines;
};
var geometrize_rasterizer_Scanline = function(y,x1,x2) {
	this.y = y;
	this.x1 = x1;
	this.x2 = x2;
};
geometrize_rasterizer_Scanline.trim = function(scanlines,w,h) {
	if(!(scanlines != null)) {
		throw new js__$Boot_HaxeError("FAIL: scanlines != null");
	}
	var w1 = w;
	var h1 = h;
	return scanlines.filter(function(a1) {
		return geometrize_rasterizer_Scanline.trimHelper(a1,w1,h1);
	});
};
geometrize_rasterizer_Scanline.trimHelper = function(line,w,h) {
	if(line.y < 0 || line.y >= h || line.x1 >= w || line.x2 < 0) {
		return false;
	}
	var value = line.x1;
	var max = w - 1;
	if(!(0 <= max)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	line.x1 = value < 0 ? 0 : value > max ? max : value;
	var value1 = line.x2;
	var max1 = w - 1;
	if(!(0 <= max1)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	line.x2 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
	return line.x1 <= line.x2;
};
var geometrize_runner_ImageRunner = function(inputImage,backgroundColor) {
	this.model = null;
	this.model = new geometrize_Model(inputImage,backgroundColor);
};
geometrize_runner_ImageRunner.prototype = {
	step: function(options) {
		return this.model.step(options.shapeTypes,options.alpha,options.candidateShapesPerStep,options.shapeMutationsPerStep);
	}
};
var geometrize_shape_Shape = function() { };
var geometrize_shape_Ellipse = function(xBound,yBound) {
	this.x = Std.random(xBound);
	this.y = Std.random(yBound);
	this.rx = Std.random(32) + 1;
	this.ry = Std.random(32) + 1;
	this.xBound = xBound;
	this.yBound = yBound;
};
geometrize_shape_Ellipse.__interfaces__ = [geometrize_shape_Shape];
geometrize_shape_Ellipse.prototype = {
	rasterize: function() {
		var lines = [];
		var aspect = this.rx / this.ry;
		var w = this.xBound;
		var h = this.yBound;
		var _g1 = 0;
		var _g = this.ry;
		while(_g1 < _g) {
			var dy = _g1++;
			var y1 = this.y - dy;
			var y2 = this.y + dy;
			if((y1 < 0 || y1 >= h) && (y2 < 0 || y2 >= h)) {
				continue;
			}
			var s = Math.sqrt(this.ry * this.ry - dy * dy) * aspect | 0;
			var x1 = this.x - s;
			var x2 = this.x + s;
			if(x1 < 0) {
				x1 = 0;
			}
			if(x2 >= w) {
				x2 = w - 1;
			}
			if(y1 >= 0 && y1 < h) {
				lines.push(new geometrize_rasterizer_Scanline(y1,x1,x2));
			}
			if(y2 >= 0 && y2 < h && dy > 0) {
				lines.push(new geometrize_rasterizer_Scanline(y2,x1,x2));
			}
		}
		return lines;
	}
	,mutate: function() {
		var r = Std.random(3);
		switch(r) {
		case 0:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value = this.x + (-16 + Math.floor(33 * Math.random()));
			var max = this.xBound - 1;
			if(!(0 <= max)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x = value < 0 ? 0 : value > max ? max : value;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value1 = this.y + (-16 + Math.floor(33 * Math.random()));
			var max1 = this.yBound - 1;
			if(!(0 <= max1)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
			break;
		case 1:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value2 = this.rx + (-16 + Math.floor(33 * Math.random()));
			var max2 = this.xBound - 1;
			if(!(1 <= max2)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.rx = value2 < 1 ? 1 : value2 > max2 ? max2 : value2;
			break;
		case 2:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value3 = this.ry + (-16 + Math.floor(33 * Math.random()));
			var max3 = this.xBound - 1;
			if(!(1 <= max3)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.ry = value3 < 1 ? 1 : value3 > max3 ? max3 : value3;
			break;
		}
	}
	,clone: function() {
		var ellipse = new geometrize_shape_Ellipse(this.xBound,this.yBound);
		ellipse.x = this.x;
		ellipse.y = this.y;
		ellipse.rx = this.rx;
		ellipse.ry = this.ry;
		return ellipse;
	}
	,getType: function() {
		return 3;
	}
	,getSvgShapeData: function() {
		return "<ellipse cx=\"" + this.x + "\" cy=\"" + this.y + "\" rx=\"" + this.rx + "\" ry=\"" + this.ry + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
	}
};
var geometrize_shape_Circle = function(xBound,yBound) {
	geometrize_shape_Ellipse.call(this,xBound,yBound);
	this.rx = Std.random(32) + 1;
	this.ry = this.rx;
};
geometrize_shape_Circle.__super__ = geometrize_shape_Ellipse;
geometrize_shape_Circle.prototype = $extend(geometrize_shape_Ellipse.prototype,{
	mutate: function() {
		var r = Std.random(2);
		switch(r) {
		case 0:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value = this.x + (-16 + Math.floor(33 * Math.random()));
			var max = this.xBound - 1;
			if(!(0 <= max)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x = value < 0 ? 0 : value > max ? max : value;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value1 = this.y + (-16 + Math.floor(33 * Math.random()));
			var max1 = this.yBound - 1;
			if(!(0 <= max1)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
			break;
		case 1:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value2 = this.rx + (-16 + Math.floor(33 * Math.random()));
			var max2 = this.xBound - 1;
			if(!(1 <= max2)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			var r1 = value2 < 1 ? 1 : value2 > max2 ? max2 : value2;
			this.rx = r1;
			this.ry = r1;
			break;
		}
	}
	,clone: function() {
		var circle = new geometrize_shape_Circle(this.xBound,this.yBound);
		circle.x = this.x;
		circle.y = this.y;
		circle.rx = this.rx;
		circle.ry = this.ry;
		return circle;
	}
	,getType: function() {
		return 5;
	}
	,getSvgShapeData: function() {
		return "<circle cx=\"" + this.x + "\" cy=\"" + this.y + "\" r=\"" + this.rx + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
	}
});
var geometrize_shape_Line = function(xBound,yBound) {
	this.x1 = Std.random(xBound);
	this.y1 = Std.random(yBound);
	var value = this.x1 + Std.random(32) + 1;
	if(!(0 <= xBound)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	this.x2 = value < 0 ? 0 : value > xBound ? xBound : value;
	var value1 = this.y1 + Std.random(32) + 1;
	if(!(0 <= yBound)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	this.y2 = value1 < 0 ? 0 : value1 > yBound ? yBound : value1;
	this.xBound = xBound;
	this.yBound = yBound;
};
geometrize_shape_Line.__interfaces__ = [geometrize_shape_Shape];
geometrize_shape_Line.prototype = {
	rasterize: function() {
		var lines = [];
		var points = geometrize_rasterizer_Rasterizer.bresenham(this.x1,this.y1,this.x2,this.y2);
		var _g = 0;
		while(_g < points.length) {
			var point = points[_g];
			++_g;
			lines.push(new geometrize_rasterizer_Scanline(point.y,point.x,point.x));
		}
		return geometrize_rasterizer_Scanline.trim(lines,this.xBound,this.yBound);
	}
	,mutate: function() {
		var r = Std.random(4);
		switch(r) {
		case 0:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value = this.x1 + (-16 + Math.floor(33 * Math.random()));
			var max = this.xBound - 1;
			if(!(0 <= max)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x1 = value < 0 ? 0 : value > max ? max : value;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value1 = this.y1 + (-16 + Math.floor(33 * Math.random()));
			var max1 = this.yBound - 1;
			if(!(0 <= max1)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y1 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
			break;
		case 1:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value2 = this.x2 + (-16 + Math.floor(33 * Math.random()));
			var max2 = this.xBound - 1;
			if(!(0 <= max2)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x2 = value2 < 0 ? 0 : value2 > max2 ? max2 : value2;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value3 = this.y2 + (-16 + Math.floor(33 * Math.random()));
			var max3 = this.yBound - 1;
			if(!(0 <= max3)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y2 = value3 < 0 ? 0 : value3 > max3 ? max3 : value3;
			break;
		}
	}
	,clone: function() {
		var line = new geometrize_shape_Line(this.xBound,this.yBound);
		line.x1 = this.x1;
		line.y1 = this.y1;
		line.x2 = this.x2;
		line.y2 = this.y2;
		return line;
	}
	,getType: function() {
		return 6;
	}
	,getSvgShapeData: function() {
		return "<line x1=\"" + this.x1 + "\" y1=\"" + this.y1 + "\" x2=\"" + this.x2 + "\" y2=\"" + this.y2 + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
	}
};
var geometrize_shape_Rectangle = function(xBound,yBound) {
	this.x1 = Std.random(xBound);
	this.y1 = Std.random(yBound);
	var value = this.x1 + Std.random(32) + 1;
	var max = xBound - 1;
	if(!(0 <= max)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	this.x2 = value < 0 ? 0 : value > max ? max : value;
	var value1 = this.y1 + Std.random(32) + 1;
	var max1 = yBound - 1;
	if(!(0 <= max1)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	this.y2 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
	this.xBound = xBound;
	this.yBound = yBound;
};
geometrize_shape_Rectangle.__interfaces__ = [geometrize_shape_Shape];
geometrize_shape_Rectangle.prototype = {
	rasterize: function() {
		var lines = [];
		var _g1 = this.y1;
		var _g = this.y2;
		while(_g1 < _g) {
			var y = _g1++;
			if(this.x1 != this.x2) {
				var first = this.x1;
				var second = this.x2;
				var first1 = this.x1;
				var second1 = this.x2;
				lines.push(new geometrize_rasterizer_Scanline(y,first < second ? first : second,first1 > second1 ? first1 : second1));
			}
		}
		return lines;
	}
	,mutate: function() {
		var r = Std.random(2);
		switch(r) {
		case 0:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value = this.x1 + (-16 + Math.floor(33 * Math.random()));
			var max = this.xBound - 1;
			if(!(0 <= max)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x1 = value < 0 ? 0 : value > max ? max : value;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value1 = this.y1 + (-16 + Math.floor(33 * Math.random()));
			var max1 = this.yBound - 1;
			if(!(0 <= max1)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y1 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
			break;
		case 1:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value2 = this.x2 + (-16 + Math.floor(33 * Math.random()));
			var max2 = this.xBound - 1;
			if(!(0 <= max2)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x2 = value2 < 0 ? 0 : value2 > max2 ? max2 : value2;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value3 = this.y2 + (-16 + Math.floor(33 * Math.random()));
			var max3 = this.yBound - 1;
			if(!(0 <= max3)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y2 = value3 < 0 ? 0 : value3 > max3 ? max3 : value3;
			break;
		}
	}
	,clone: function() {
		var rectangle = new geometrize_shape_Rectangle(this.xBound,this.yBound);
		rectangle.x1 = this.x1;
		rectangle.y1 = this.y1;
		rectangle.x2 = this.x2;
		rectangle.y2 = this.y2;
		return rectangle;
	}
	,getType: function() {
		return 0;
	}
	,getSvgShapeData: function() {
		var first = this.x1;
		var second = this.x2;
		var first1 = this.y1;
		var second1 = this.y2;
		var first2 = this.x1;
		var second2 = this.x2;
		var first3 = this.x1;
		var second3 = this.x2;
		var first4 = this.y1;
		var second4 = this.y2;
		var first5 = this.y1;
		var second5 = this.y2;
		return "<rect x=\"" + (first < second ? first : second) + "\" y=\"" + (first1 < second1 ? first1 : second1) + "\" width=\"" + ((first2 > second2 ? first2 : second2) - (first3 < second3 ? first3 : second3)) + "\" height=\"" + ((first4 > second4 ? first4 : second4) - (first5 < second5 ? first5 : second5)) + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
	}
};
var geometrize_shape_RotatedEllipse = function(xBound,yBound) {
	this.x = Std.random(xBound);
	this.y = Std.random(yBound);
	this.rx = Std.random(32) + 1;
	this.ry = Std.random(32) + 1;
	this.angle = Std.random(360);
	this.xBound = xBound;
	this.yBound = yBound;
};
geometrize_shape_RotatedEllipse.__interfaces__ = [geometrize_shape_Shape];
geometrize_shape_RotatedEllipse.prototype = {
	rasterize: function() {
		var pointCount = 20;
		var points = [];
		var rads = this.angle * (Math.PI / 180.0);
		var c = Math.cos(rads);
		var s = Math.sin(rads);
		var _g1 = 0;
		var _g = pointCount;
		while(_g1 < _g) {
			var i = _g1++;
			var rot = 360.0 / pointCount * i * (Math.PI / 180.0);
			var crx = this.rx * Math.cos(rot);
			var cry = this.ry * Math.sin(rot);
			var tx = crx * c - cry * s + this.x | 0;
			var ty = crx * s + cry * c + this.y | 0;
			points.push({ x : tx, y : ty});
		}
		return geometrize_rasterizer_Scanline.trim(geometrize_rasterizer_Rasterizer.scanlinesForPolygon(points),this.xBound,this.yBound);
	}
	,mutate: function() {
		var r = Std.random(4);
		switch(r) {
		case 0:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value = this.x + (-16 + Math.floor(33 * Math.random()));
			var max = this.xBound - 1;
			if(!(0 <= max)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x = value < 0 ? 0 : value > max ? max : value;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value1 = this.y + (-16 + Math.floor(33 * Math.random()));
			var max1 = this.yBound - 1;
			if(!(0 <= max1)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
			break;
		case 1:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value2 = this.rx + (-16 + Math.floor(33 * Math.random()));
			var max2 = this.xBound - 1;
			if(!(1 <= max2)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.rx = value2 < 1 ? 1 : value2 > max2 ? max2 : value2;
			break;
		case 2:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value3 = this.ry + (-16 + Math.floor(33 * Math.random()));
			var max3 = this.yBound - 1;
			if(!(1 <= max3)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.ry = value3 < 1 ? 1 : value3 > max3 ? max3 : value3;
			break;
		case 3:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value4 = this.angle + (-4 + Math.floor(9 * Math.random()));
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.angle = value4 < 0 ? 0 : value4 > 360 ? 360 : value4;
			break;
		}
	}
	,clone: function() {
		var ellipse = new geometrize_shape_RotatedEllipse(this.xBound,this.yBound);
		ellipse.x = this.x;
		ellipse.y = this.y;
		ellipse.rx = this.rx;
		ellipse.ry = this.ry;
		ellipse.angle = this.angle;
		return ellipse;
	}
	,getType: function() {
		return 4;
	}
	,getSvgShapeData: function() {
		var s = "<g transform=\"translate(" + this.x + " " + this.y + ") rotate(" + this.angle + ") scale(" + this.rx + " " + this.ry + ")\">";
		s += "<ellipse cx=\"" + 0 + "\" cy=\"" + 0 + "\" rx=\"" + 1 + "\" ry=\"" + 1 + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
		s += "</g>";
		return s;
	}
};
var geometrize_shape_RotatedRectangle = function(xBound,yBound) {
	this.x1 = Std.random(xBound);
	this.y1 = Std.random(yBound);
	var value = this.x1 + Std.random(32) + 1;
	if(!(0 <= xBound)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	this.x2 = value < 0 ? 0 : value > xBound ? xBound : value;
	var value1 = this.y1 + Std.random(32) + 1;
	if(!(0 <= yBound)) {
		throw new js__$Boot_HaxeError("FAIL: min <= max");
	}
	this.y2 = value1 < 0 ? 0 : value1 > yBound ? yBound : value1;
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: lower <= upper");
	}
	this.angle = Math.floor(361 * Math.random());
	this.xBound = xBound;
	this.yBound = yBound;
};
geometrize_shape_RotatedRectangle.__interfaces__ = [geometrize_shape_Shape];
geometrize_shape_RotatedRectangle.prototype = {
	rasterize: function() {
		var first = this.x1;
		var second = this.x2;
		var xm1 = first < second ? first : second;
		var first1 = this.x1;
		var second1 = this.x2;
		var xm2 = first1 > second1 ? first1 : second1;
		var first2 = this.y1;
		var second2 = this.y2;
		var ym1 = first2 < second2 ? first2 : second2;
		var first3 = this.y1;
		var second3 = this.y2;
		var ym2 = first3 > second3 ? first3 : second3;
		var cx = (xm1 + xm2) / 2 | 0;
		var cy = (ym1 + ym2) / 2 | 0;
		var ox1 = xm1 - cx;
		var ox2 = xm2 - cx;
		var oy1 = ym1 - cy;
		var oy2 = ym2 - cy;
		var rads = this.angle * Math.PI / 180.0;
		var c = Math.cos(rads);
		var s = Math.sin(rads);
		var ulx = ox1 * c - oy1 * s + cx | 0;
		var uly = ox1 * s + oy1 * c + cy | 0;
		var blx = ox1 * c - oy2 * s + cx | 0;
		var bly = ox1 * s + oy2 * c + cy | 0;
		var urx = ox2 * c - oy1 * s + cx | 0;
		var ury = ox2 * s + oy1 * c + cy | 0;
		var brx = ox2 * c - oy2 * s + cx | 0;
		var bry = ox2 * s + oy2 * c + cy | 0;
		return geometrize_rasterizer_Scanline.trim(geometrize_rasterizer_Rasterizer.scanlinesForPolygon([{ x : ulx, y : uly},{ x : urx, y : ury},{ x : brx, y : bry},{ x : blx, y : bly}]),this.xBound,this.yBound);
	}
	,mutate: function() {
		var r = Std.random(3);
		switch(r) {
		case 0:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value = this.x1 + (-16 + Math.floor(33 * Math.random()));
			var max = this.xBound - 1;
			if(!(0 <= max)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x1 = value < 0 ? 0 : value > max ? max : value;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value1 = this.y1 + (-16 + Math.floor(33 * Math.random()));
			var max1 = this.yBound - 1;
			if(!(0 <= max1)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y1 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
			break;
		case 1:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value2 = this.x2 + (-16 + Math.floor(33 * Math.random()));
			var max2 = this.xBound - 1;
			if(!(0 <= max2)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x2 = value2 < 0 ? 0 : value2 > max2 ? max2 : value2;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value3 = this.y2 + (-16 + Math.floor(33 * Math.random()));
			var max3 = this.yBound - 1;
			if(!(0 <= max3)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y2 = value3 < 0 ? 0 : value3 > max3 ? max3 : value3;
			break;
		case 2:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value4 = this.angle + (-4 + Math.floor(9 * Math.random()));
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.angle = value4 < 0 ? 0 : value4 > 360 ? 360 : value4;
			break;
		}
	}
	,clone: function() {
		var rectangle = new geometrize_shape_RotatedRectangle(this.xBound,this.yBound);
		rectangle.x1 = this.x1;
		rectangle.y1 = this.y1;
		rectangle.x2 = this.x2;
		rectangle.y2 = this.y2;
		rectangle.angle = this.angle;
		return rectangle;
	}
	,getType: function() {
		return 1;
	}
	,getSvgShapeData: function() {
		var first = this.x1;
		var second = this.x2;
		var xm1 = first < second ? first : second;
		var first1 = this.x1;
		var second1 = this.x2;
		var xm2 = first1 > second1 ? first1 : second1;
		var first2 = this.y1;
		var second2 = this.y2;
		var ym1 = first2 < second2 ? first2 : second2;
		var first3 = this.y1;
		var second3 = this.y2;
		var ym2 = first3 > second3 ? first3 : second3;
		var cx = (xm1 + xm2) / 2 | 0;
		var cy = (ym1 + ym2) / 2 | 0;
		var ox1 = xm1 - cx;
		var ox2 = xm2 - cx;
		var oy1 = ym1 - cy;
		var oy2 = ym2 - cy;
		var rads = this.angle * Math.PI / 180.0;
		var c = Math.cos(rads);
		var s = Math.sin(rads);
		var ulx = ox1 * c - oy1 * s + cx | 0;
		var uly = ox1 * s + oy1 * c + cy | 0;
		var blx = ox1 * c - oy2 * s + cx | 0;
		var bly = ox1 * s + oy2 * c + cy | 0;
		var urx = ox2 * c - oy1 * s + cx | 0;
		var ury = ox2 * s + oy1 * c + cy | 0;
		var brx = ox2 * c - oy2 * s + cx | 0;
		var bry = ox2 * s + oy2 * c + cy | 0;
		var points = [{ x : ulx, y : uly},{ x : urx, y : ury},{ x : brx, y : bry},{ x : blx, y : bly}];
		var s1 = "<polygon points=\"";
		var _g1 = 0;
		var _g = points.length;
		while(_g1 < _g) {
			var i = _g1++;
			s1 += points[i].x + " " + points[i].y;
			if(i != points.length - 1) {
				s1 += " ";
			}
		}
		s1 += "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + "/>";
		return s1;
	}
};
var geometrize_shape_ShapeFactory = function() { };
geometrize_shape_ShapeFactory.create = function(type,xBound,yBound) {
	switch(type) {
	case 0:
		return new geometrize_shape_Rectangle(xBound,yBound);
	case 1:
		return new geometrize_shape_RotatedRectangle(xBound,yBound);
	case 2:
		return new geometrize_shape_Triangle(xBound,yBound);
	case 3:
		return new geometrize_shape_Ellipse(xBound,yBound);
	case 4:
		return new geometrize_shape_RotatedEllipse(xBound,yBound);
	case 5:
		return new geometrize_shape_Circle(xBound,yBound);
	case 6:
		return new geometrize_shape_Line(xBound,yBound);
	}
};
geometrize_shape_ShapeFactory.randomShapeOf = function(types,xBound,yBound) {
	if(!(types != null && types.length > 0)) {
		throw new js__$Boot_HaxeError("FAIL: a != null && a.length > 0");
	}
	var upper = types.length - 1;
	if(!(0 <= upper)) {
		throw new js__$Boot_HaxeError("FAIL: lower <= upper");
	}
	return geometrize_shape_ShapeFactory.create(types[Math.floor((upper + 1) * Math.random())],xBound,yBound);
};
var geometrize_shape_Triangle = function(xBound,yBound) {
	this.x1 = Std.random(xBound);
	this.y1 = Std.random(yBound);
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: lower <= upper");
	}
	this.x2 = this.x1 + (-16 + Math.floor(33 * Math.random()));
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: lower <= upper");
	}
	this.y2 = this.y1 + (-16 + Math.floor(33 * Math.random()));
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: lower <= upper");
	}
	this.x3 = this.x1 + (-16 + Math.floor(33 * Math.random()));
	if(!true) {
		throw new js__$Boot_HaxeError("FAIL: lower <= upper");
	}
	this.y3 = this.y1 + (-16 + Math.floor(33 * Math.random()));
	this.xBound = xBound;
	this.yBound = yBound;
};
geometrize_shape_Triangle.__interfaces__ = [geometrize_shape_Shape];
geometrize_shape_Triangle.prototype = {
	rasterize: function() {
		return geometrize_rasterizer_Scanline.trim(geometrize_rasterizer_Rasterizer.scanlinesForPolygon([{ x : this.x1, y : this.y1},{ x : this.x2, y : this.y2},{ x : this.x3, y : this.y3}]),this.xBound,this.yBound);
	}
	,mutate: function() {
		var r = Std.random(3);
		switch(r) {
		case 0:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value = this.x1 + (-16 + Math.floor(33 * Math.random()));
			var max = this.xBound - 1;
			if(!(0 <= max)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x1 = value < 0 ? 0 : value > max ? max : value;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value1 = this.y1 + (-16 + Math.floor(33 * Math.random()));
			var max1 = this.yBound - 1;
			if(!(0 <= max1)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y1 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
			break;
		case 1:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value2 = this.x2 + (-16 + Math.floor(33 * Math.random()));
			var max2 = this.xBound - 1;
			if(!(0 <= max2)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x2 = value2 < 0 ? 0 : value2 > max2 ? max2 : value2;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value3 = this.y2 + (-16 + Math.floor(33 * Math.random()));
			var max3 = this.yBound - 1;
			if(!(0 <= max3)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y2 = value3 < 0 ? 0 : value3 > max3 ? max3 : value3;
			break;
		case 2:
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value4 = this.x3 + (-16 + Math.floor(33 * Math.random()));
			var max4 = this.xBound - 1;
			if(!(0 <= max4)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.x3 = value4 < 0 ? 0 : value4 > max4 ? max4 : value4;
			if(!true) {
				throw new js__$Boot_HaxeError("FAIL: lower <= upper");
			}
			var value5 = this.y3 + (-16 + Math.floor(33 * Math.random()));
			var max5 = this.yBound - 1;
			if(!(0 <= max5)) {
				throw new js__$Boot_HaxeError("FAIL: min <= max");
			}
			this.y3 = value5 < 0 ? 0 : value5 > max5 ? max5 : value5;
			break;
		}
	}
	,clone: function() {
		var triangle = new geometrize_shape_Triangle(this.xBound,this.yBound);
		triangle.x1 = this.x1;
		triangle.y1 = this.y1;
		triangle.x2 = this.x2;
		triangle.y2 = this.y2;
		triangle.x3 = this.x3;
		triangle.y3 = this.y3;
		return triangle;
	}
	,getType: function() {
		return 2;
	}
	,getSvgShapeData: function() {
		return "<polygon points=\"" + this.x1 + "," + this.y1 + " " + this.x2 + "," + this.y2 + " " + this.x3 + "," + this.y3 + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + "/>";
	}
};
var haxe_IMap = function() { };
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) {
			a.push(key | 0);
		}
		return HxOverrides.iter(a);
	}
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
onmessage = GeometrizeWorker.prototype.messageHandler;
geometrize_exporter_SvgExporter.SVG_STYLE_HOOK = "::svg_style_hook::";
})();
